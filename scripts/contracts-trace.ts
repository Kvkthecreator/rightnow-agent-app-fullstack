#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const { glob } = require('glob');

interface ContractUsage {
  apis: Array<{ method: string; path: string; file: string }>;
  components: Array<{ name: string; file: string }>;
  pages: Array<{ route: string; file: string }>;
}

const contractsMap: Record<string, ContractUsage> = {};

// Regex patterns for parsing annotations
const routePattern = /^\s*Route:\s*(\w+)\s+(.+)$/m;
const componentPattern = /^\s*Component:\s*(.+)$/m;
const pagePattern = /^\s*Page:\s*(.+)$/m;
const contractInputPattern = /^\s*@contract\s+input\s*:\s*(.+)$/m;
const contractOutputPattern = /^\s*@contract\s+output\s*:\s*(.+)$/m;
const contractRendersPattern = /^\s*@contract\s+renders\s*:\s*(.+)$/m;

function extractContracts(content: string): string[] {
  const contracts: string[] = [];
  
  // Extract from all @contract annotations
  const patterns = [contractInputPattern, contractOutputPattern, contractRendersPattern];
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match && match[1]) {
      // Split by comma, pipe, and trim each contract name
      const contractNames = match[1]
        .split(/[,|]/)
        .map(c => c.trim())
        .filter(c => c && c !== '<none>' && c !== 'none');
      contracts.push(...contractNames);
    }
  }
  
  return contracts;
}

function parseFile(filePath: string, content: string) {
  // Skip if no JSDoc/docstring block
  if (!content.includes('/**') && !content.includes('"""')) {
    return;
  }

  // Extract the header block
  let headerMatch = content.match(/\/\*\*([\s\S]*?)\*\//);
  if (!headerMatch && filePath.endsWith('.py')) {
    headerMatch = content.match(/"""([\s\S]*?)"""/);
  }
  
  if (!headerMatch) return;
  
  const header = headerMatch[1];
  const contracts = extractContracts(header);
  
  if (contracts.length === 0) return;

  // Parse route info for API files
  const routeMatch = header.match(routePattern);
  if (routeMatch) {
    const method = routeMatch[1];
    const routePath = routeMatch[2];
    
    for (const contract of contracts) {
      if (!contractsMap[contract]) {
        contractsMap[contract] = { apis: [], components: [], pages: [] };
      }
      contractsMap[contract].apis.push({
        method,
        path: routePath,
        file: path.relative(process.cwd(), filePath)
      });
    }
  }

  // Parse component info
  const componentMatch = header.match(componentPattern);
  if (componentMatch) {
    const componentName = componentMatch[1].trim();
    
    for (const contract of contracts) {
      if (!contractsMap[contract]) {
        contractsMap[contract] = { apis: [], components: [], pages: [] };
      }
      contractsMap[contract].components.push({
        name: componentName,
        file: path.relative(process.cwd(), filePath)
      });
    }
  }

  // Parse page info
  const pageMatch = header.match(pagePattern);
  if (pageMatch) {
    const pageRoute = pageMatch[1].trim();
    
    for (const contract of contracts) {
      if (!contractsMap[contract]) {
        contractsMap[contract] = { apis: [], components: [], pages: [] };
      }
      contractsMap[contract].pages.push({
        route: pageRoute,
        file: path.relative(process.cwd(), filePath)
      });
    }
  }
}

async function scanFiles() {
  // Scan TypeScript/React files in web
  const tsFiles = await glob('web/**/*.{ts,tsx}', {
    ignore: ['**/node_modules/**', '**/*.test.*', '**/*.spec.*']
  });
  
  for (const file of tsFiles) {
    const content = fs.readFileSync(file, 'utf-8');
    parseFile(file, content);
  }

  // Scan Python files in api
  const pyFiles = await glob('api/src/**/*.py', {
    ignore: ['**/venv/**', '**/__pycache__/**', '**/*.pyc']
  });
  
  for (const file of pyFiles) {
    if (fs.existsSync(file)) {
      const content = fs.readFileSync(file, 'utf-8');
      parseFile(file, content);
    }
  }
}

function generateRegistry(): string {
  let markdown = '# Contracts Registry (Source of Truth: /shared/contracts)\n\n';
  markdown += '> Generated by `pnpm contracts:trace`. Do not edit by hand.\n\n';

  const sortedContracts = Object.keys(contractsMap).sort();
  
  for (const contract of sortedContracts) {
    const usage = contractsMap[contract];
    
    markdown += `## ${contract}\n`;
    
    if (usage.apis.length > 0) {
      markdown += '**APIs**\n';
      for (const api of usage.apis) {
        markdown += `- ${api.method} ${api.path} — \`${api.file}\`\n`;
      }
      markdown += '\n';
    }
    
    if (usage.components.length > 0) {
      markdown += '**Components**\n';
      for (const component of usage.components) {
        markdown += `- ${component.name} — \`${component.file}\`\n`;
      }
      markdown += '\n';
    }
    
    if (usage.pages.length > 0) {
      markdown += '**Pages**\n';
      for (const page of usage.pages) {
        markdown += `- ${page.route} — \`${page.file}\`\n`;
      }
      markdown += '\n';
    }
    
    markdown += '---\n\n';
  }
  
  return markdown.trimEnd() + '\n';
}

async function main() {
  console.log('Scanning for contract usage...');
  await scanFiles();
  
  console.log(`Found ${Object.keys(contractsMap).length} contracts in use`);
  
  const registry = generateRegistry();
  const registryPath = path.join(process.cwd(), 'shared/contracts/REGISTRY.md');
  
  fs.writeFileSync(registryPath, registry);
  console.log(`Generated ${registryPath}`);
}

main().catch(console.error);