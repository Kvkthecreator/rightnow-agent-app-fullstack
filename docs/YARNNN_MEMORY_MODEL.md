# YARNNN Memory Model — Unified Data & Substrate Architecture

**The Single Source of Truth for Memory Layer, Substrate Relationships, and Data Flow**

This document consolidates the canonical substrate contract, relational model, and semantic flows into a comprehensive memory architecture reference.

Aligned with Context OS substrate v1.2
Blocks (**context_blocks**) are structured knowledge ingredients extracted from raw_dumps. Each block contains goals, constraints, metrics, entities, relationships, and provenance.
Last updated: 2025-07-25

---

## 1. Core Principle

The memory model captures, structures, and evolves cognitive inputs as **decoupled, composable substrates**.  
No substrate assumes the existence of another. All reference a shared `basket_id`.

---

## 2. Canonical Data Types

### Substrate Types (Pure Memory Layer)
| Type          | Description                          | Created When             |
| ------------- | ------------------------------------ | ------------------------ |
| `block`       | Structured knowledge ingredients     | Extracted by P1 agent    |
| `dump`        | Immutable unstructured input         | User submits dump        |
| `context_item`| Semantic connective tissue           | Created by P2 agent      |
| `timeline_event`| System activity audit log          | Emitted by system        |

### Artifact Types (Expression Layer)
| Type          | Description                          | Created When             |
| ------------- | ------------------------------------ | ------------------------ |
| `document`    | Versioned narrative compositions     | Composed by P4/user      |
| `reflection`  | Computed insights from substrate     | Generated by P3 agent    |

### Memory Plane (Substrate Only)
- **timeline_events**: Append-only memory stream of all substrate activity
- **substrate_relationships**: Links between substrate entities
- **Integration**: Pure substrate memory → computed artifacts → user interface

### Artifact Storage (Separate Layer)
- **documents**: Versioned compositions with git-like snapshots
- **reflections**: Computed insights targeting substrates OR document versions
- **document_versions**: Immutable snapshots for stable artifact references

Artifacts derive from substrate but exist independently. Documents can be freely edited; reflections can target substrate or document snapshots.

---

## 3. Substrate Lifecycle (Decoupled)

- Each substrate is explicitly created.  
- All reference the same `basket_id`.  
- No linear creation flow is enforced.

```mermaid
flowchart TD
    A([basket]) --> B1([raw_dump])
    A --> B2([block])
    A --> B3([document])
    A --> B4([context_item])

    B1 -->|agent interprets| B2
    B2 -->|composed in| B3
    B3 -->|tagged by| B4
    B2 -->|tagged by| B4
4. Memory Guarantees
Type	Mutability	Evolves	Source of Truth
raw_dump	Immutable	No	Yes (verbatim)
block	Revisable	Yes	Derived
document	Versioned	Yes	Composed
context_item	Governed	Yes	Derived (via proposals)
basket	Static ID	No	No
event	Immutable	No	Log only
5. Canonical Role Definitions
🧺 basket
Memory scope for all substrates.
Organizes raw_dumps, context_blocks, documents, context_items.
💭 raw_dump
Unstructured input, immutable.
May be referenced by context_blocks or documents.
⬛ block
Structured knowledge ingredient extracted from raw_dumps.
Contains semantic data (goals, constraints, metrics, entities) with transformation capabilities.
Agents extract these as data ingredients for document synthesis.
Lifecycle: PROPOSED → ACCEPTED → LOCKED → CONSTANT.
📄 document
Synthesized artifact generated from block ingredients + context_items + user intent.
P4 agent transforms ingredient data into coherent narratives.
Not a source of memory, but a generated expression of accumulated knowledge.
🏷️ context_item
Semantic connector (tags/themes).
May link to blocks, documents, baskets.
User-declared or agent-inferred.
Lifecycle: PROVISIONAL → PROPOSED → ACTIVE → [DEPRECATED | MERGED].
📜 event
Immutable audit entry.
Records creations, updates, proposals, rejections, and compositions.
6. Canonical Summary
All substrates are peers — no hierarchy.
Blocks (**context_blocks**) are structured knowledge ingredients with transformation capabilities.
Documents are synthesized artifacts, not manual compositions.
Narrative text is generated from ingredient data, not manually authored.
Events ensure full auditability and immutability.

---

## 🔗 Unified Relational Model

### Substrate Role Definitions

| Role              | Layer    | Type(s)           | Description |
| ----------------- | -------- | ----------------- | ----------- |
| Capture           | Substrate| `dump`            | Immutable input stream (raw_dumps) |
| Interpretation    | Substrate| `block`           | Structured units (context_blocks) |
| Threading         | Substrate| `context_item`    | Semantic connectors |
| Activity Log      | Substrate| `timeline_event`  | System audit trail |
| Compositions      | Artifact | `document`        | Versioned narrative expressions |
| Insights          | Artifact | `reflection`      | Computed patterns/tensions |
| Scope Container   | Meta     | `basket`          | Workspace boundary |

### Memory Plane Components (Substrate Only)

| Component | Purpose | Storage |
|-----------|---------|---------|
| substrate_references | Links substrate to documents | substrate_type, substrate_id |
| timeline_events | Append-only memory stream | kind, ts, ref_id, preview, payload |
| substrate_relationships | Links between substrate entities | source_id, target_id, relationship_type |

### Artifact Plane Components (Separate)

| Component | Purpose | Storage |
|-----------|---------|---------|
| document_versions | Git-like versioning | version_hash, content, metadata |
| reflections_artifact | Computed insights | target_type, target_id, reflection_text |
| Change Tracker | `event`, `revision` | Logs of evolution across types |
| Composer | `agent`, `user` | Actor that creates/edits content |

### Substrate Lifecycle Management

**Basket Lifecycle**: `INIT → ACTIVE → ARCHIVED`
- Empty INIT baskets older than **48h** are **eligible for cleanup** (policy-guarded; disabled by default)

**Block Lifecycle**: `PROPOSED → ACCEPTED → LOCKED → CONSTANT`
- Blocks evolve through governance states with agent and human review

**Context Item Lifecycle**: `PROVISIONAL → PROPOSED → ACTIVE → [DEPRECATED | MERGED]`
- Semantic connectors follow governance flow for quality control

### Semantic Flow Patterns

**Core Relationships:**
- `raw_dump` → may be interpreted into `context_blocks`, annotated with `context_items`, or referenced directly
- `context_block` → reusable unit, may be included in `documents`
- `document` → composed from selected `context_blocks`, `narrative`, and `context_items`
- `context_item` → can label or connect dumps, context_blocks, or documents
- `events`/`revisions` → record changes without mutating originals
- `basket` → contains all activity, but imposes no linear flow

### Data Flow Architecture

```
Raw Input → Capture → Interpretation → Composition → Expression
    ↓         ↓           ↓             ↓           ↓
raw_dumps → blocks → context_items → documents → reflections
    │         │           │             │           │
    └─────────┼───────────┼─────────────┼───────────┘
              │           │             │
          timeline_events (audit log for all)
```

### Integration Patterns

**Pure Substrate Memory → Computed Artifacts → User Interface**
1. Substrate layer provides the authoritative memory foundation
2. Artifacts derive insights and compositions from substrate
3. User interface presents both substrate and artifacts with clear separation
4. No artifact recursion - artifacts don't become substrate for other artifacts

### Memory Guarantees Matrix

| Type | Mutability | Evolves | Source of Truth |
|------|------------|---------|-----------------|
| raw_dump | Immutable | No | Yes (verbatim) |
| block | Revisable | Yes | Derived |
| document | Versioned | Yes | Composed |
| context_item | Governed | Yes | Derived (via proposals) |
| basket | Static ID | No | No |
| event | Immutable | No | Log only |
| reflection | Computed | Yes | Derived |

This unified memory model ensures substrate equality, clear artifact separation, and robust data flow patterns that support the full YARNNN cognitive architecture.