// ============================================================================
// CHANGE ANCESTRY & ROLLBACK SYSTEM
// ============================================================================
// Track change lineage and enable sophisticated rollback capabilities
// Supports selective rollback, change dependency analysis, and version reconstruction

export interface ChangeNode {
  id: string;
  userId: string;
  timestamp: string;
  changeType: string;
  documentId: string;
  content: any;
  metadata: {
    description: string;
    affectedRanges?: Array<{ start: number; end: number }>;
    dependencies?: string[]; // IDs of changes this depends on
    conflicts?: string[];    // IDs of changes this conflicts with
    autoGenerated?: boolean;
    source?: 'user' | 'system' | 'ai' | 'merge';
  };
  parentNodes: string[];     // Direct parents in the change tree
  childNodes: string[];      // Direct children in the change tree
  version: number;
  checksum: string;          // Content hash for integrity
}

export interface ChangeTree {
  documentId: string;
  rootNode: string;          // Initial document state
  nodes: Map<string, ChangeNode>;
  branches: Map<string, string[]>; // Branch name to node IDs
  activeNode: string;        // Current HEAD
  lastModified: string;
}

export interface RollbackPlan {
  id: string;
  targetNodeId: string;
  affectedNodes: string[];
  strategy: 'linear' | 'selective' | 'branch_merge' | 'cherry_pick';
  conflicts: RollbackConflict[];
  estimatedComplexity: 'simple' | 'moderate' | 'complex';
  previewChanges: Array<{
    type: 'add' | 'remove' | 'modify';
    nodeId: string;
    description: string;
  }>;
  warnings: string[];
}

export interface RollbackConflict {
  id: string;
  type: 'dependency' | 'concurrent_modification' | 'branch_divergence';
  description: string;
  affectedNodes: string[];
  resolutionOptions: Array<{
    strategy: string;
    description: string;
    safe: boolean;
  }>;
}

export interface RollbackResult {
  success: boolean;
  newActiveNode: string;
  appliedChanges: string[];
  resolvedConflicts: string[];
  warnings: string[];
  newDocumentState: any;
  rollbackId: string;
}

/**
 * Change Ancestry Manager
 * 
 * Provides sophisticated change tracking and rollback capabilities:
 * - Build and maintain change trees with full lineage
 * - Track dependencies between changes
 * - Enable selective rollback without breaking dependencies
 * - Support branch merging and cherry-picking
 * - Analyze change impact and conflicts
 * - Reconstruct any historical state
 */
export class ChangeAncestryManager {
  private changeTrees: Map<string, ChangeTree> = new Map();
  private rollbackHistory: Map<string, RollbackResult[]> = new Map();

  // ========================================================================
  // CHANGE TRACKING
  // ========================================================================

  /**
   * Add a new change to the ancestry tree
   */
  addChange(
    documentId: string,
    change: Omit<ChangeNode, 'parentNodes' | 'childNodes' | 'version' | 'checksum'>
  ): ChangeNode {
    const tree = this.getOrCreateTree(documentId);
    const parentNode = tree.nodes.get(tree.activeNode);
    
    const newNode: ChangeNode = {
      ...change,
      parentNodes: parentNode ? [tree.activeNode] : [],
      childNodes: [],
      version: parentNode ? parentNode.version + 1 : 1,
      checksum: this.calculateChecksum(change.content)
    };

    // Add to tree
    tree.nodes.set(newNode.id, newNode);
    
    // Update parent's children
    if (parentNode) {
      parentNode.childNodes.push(newNode.id);
    }

    // Update tree state
    tree.activeNode = newNode.id;
    tree.lastModified = newNode.timestamp;

    // Add to current branch
    const currentBranch = tree.branches.get('main') || [];
    currentBranch.push(newNode.id);
    tree.branches.set('main', currentBranch);

    console.log(`üìù Added change ${newNode.id} to document ${documentId}, version ${newNode.version}`);
    
    return newNode;
  }

  /**
   * Create a new branch from a specific node
   */
  createBranch(documentId: string, branchName: string, fromNodeId: string): boolean {
    const tree = this.getTree(documentId);
    if (!tree || !tree.nodes.has(fromNodeId)) {
      return false;
    }

    if (tree.branches.has(branchName)) {
      return false; // Branch already exists
    }

    // Create branch with path from root to the node
    const branchPath = this.getPathToNode(tree, fromNodeId);
    tree.branches.set(branchName, branchPath);

    console.log(`üåø Created branch '${branchName}' from node ${fromNodeId}`);
    return true;
  }

  /**
   * Merge a branch into another branch
   */
  async mergeBranch(
    documentId: string,
    sourceBranch: string,
    targetBranch: string,
    mergeStrategy: 'auto' | 'manual' = 'auto'
  ): Promise<RollbackResult> {
    const tree = this.getTree(documentId);
    if (!tree || !tree.branches.has(sourceBranch) || !tree.branches.has(targetBranch)) {
      throw new Error('Invalid branch for merge');
    }

    const sourceNodes = tree.branches.get(sourceBranch)!;
    const targetNodes = tree.branches.get(targetBranch)!;

    // Find common ancestor
    const commonAncestor = this.findCommonAncestor(tree, sourceNodes, targetNodes);
    
    // Get changes to merge
    const changesToMerge = sourceNodes.filter(nodeId => {
      const nodeIndex = sourceNodes.indexOf(nodeId);
      const ancestorIndex = sourceNodes.indexOf(commonAncestor);
      return nodeIndex > ancestorIndex;
    });

    // Create merge plan
    const plan = await this.createMergePlan(tree, changesToMerge, targetNodes);
    
    // Execute merge
    return await this.executeMergePlan(documentId, plan);
  }

  // ========================================================================
  // ROLLBACK PLANNING
  // ========================================================================

  /**
   * Create a rollback plan to a specific node
   */
  async createRollbackPlan(
    documentId: string,
    targetNodeId: string,
    strategy: RollbackPlan['strategy'] = 'linear'
  ): Promise<RollbackPlan> {
    const tree = this.getTree(documentId);
    if (!tree || !tree.nodes.has(targetNodeId)) {
      throw new Error('Invalid target node for rollback');
    }

    const targetNode = tree.nodes.get(targetNodeId)!;
    const currentNode = tree.nodes.get(tree.activeNode)!;

    // Analyze the rollback requirements
    const analysis = await this.analyzeRollbackPath(tree, targetNodeId, tree.activeNode, strategy);

    const plan: RollbackPlan = {
      id: crypto.randomUUID(),
      targetNodeId,
      affectedNodes: analysis.affectedNodes,
      strategy,
      conflicts: analysis.conflicts,
      estimatedComplexity: this.calculateComplexity(analysis),
      previewChanges: analysis.previewChanges,
      warnings: analysis.warnings
    };

    return plan;
  }

  /**
   * Execute a rollback plan
   */
  async executeRollback(documentId: string, plan: RollbackPlan): Promise<RollbackResult> {
    const tree = this.getTree(documentId);
    if (!tree) {
      throw new Error('Document tree not found');
    }

    const rollbackId = crypto.randomUUID();
    
    try {
      // Validate plan is still valid
      const validationResult = await this.validateRollbackPlan(tree, plan);
      if (!validationResult.valid) {
        throw new Error(`Rollback plan invalid: ${validationResult.reason}`);
      }

      // Execute based on strategy
      let result: RollbackResult;
      
      switch (plan.strategy) {
        case 'linear':
          result = await this.executeLinearRollback(tree, plan);
          break;
        case 'selective':
          result = await this.executeSelectiveRollback(tree, plan);
          break;
        case 'branch_merge':
          result = await this.executeBranchMergeRollback(tree, plan);
          break;
        case 'cherry_pick':
          result = await this.executeCherryPickRollback(tree, plan);
          break;
        default:
          throw new Error(`Unsupported rollback strategy: ${plan.strategy}`);
      }

      // Record rollback in history
      this.recordRollback(documentId, result);

      console.log(`‚è™ Executed rollback ${rollbackId} on document ${documentId}`);
      return result;

    } catch (error) {
      const failedResult: RollbackResult = {
        success: false,
        newActiveNode: tree.activeNode,
        appliedChanges: [],
        resolvedConflicts: [],
        warnings: [`Rollback failed: ${error instanceof Error ? error.message : 'Unknown error'}`],
        newDocumentState: this.reconstructDocumentState(tree, tree.activeNode),
        rollbackId
      };

      this.recordRollback(documentId, failedResult);
      return failedResult;
    }
  }

  // ========================================================================
  // ROLLBACK EXECUTION STRATEGIES
  // ========================================================================

  private async executeLinearRollback(tree: ChangeTree, plan: RollbackPlan): Promise<RollbackResult> {
    // Simple linear rollback - undo changes in reverse chronological order
    const path = this.getPathBetweenNodes(tree, plan.targetNodeId, tree.activeNode);
    const changesToUndo = path.reverse();

    const newDocumentState = this.reconstructDocumentState(tree, plan.targetNodeId);
    
    return {
      success: true,
      newActiveNode: plan.targetNodeId,
      appliedChanges: changesToUndo,
      resolvedConflicts: [],
      warnings: [],
      newDocumentState,
      rollbackId: crypto.randomUUID()
    };
  }

  private async executeSelectiveRollback(tree: ChangeTree, plan: RollbackPlan): Promise<RollbackResult> {
    // Selective rollback - undo specific changes while preserving others
    const affectedChanges: string[] = [];
    const warnings: string[] = [];

    // Check dependencies
    for (const nodeId of plan.affectedNodes) {
      const node = tree.nodes.get(nodeId)!;
      if (node.metadata.dependencies) {
        const dependencyConflicts = node.metadata.dependencies.filter(depId => 
          !plan.affectedNodes.includes(depId)
        );
        
        if (dependencyConflicts.length > 0) {
          warnings.push(`Change ${nodeId} depends on changes that won't be rolled back`);
        }
      }
    }

    // Apply selective changes
    const newDocumentState = await this.applySelectiveChanges(tree, plan.affectedNodes);
    
    return {
      success: true,
      newActiveNode: tree.activeNode, // Don't change active node in selective rollback
      appliedChanges: plan.affectedNodes,
      resolvedConflicts: [],
      warnings,
      newDocumentState,
      rollbackId: crypto.randomUUID()
    };
  }

  private async executeBranchMergeRollback(tree: ChangeTree, plan: RollbackPlan): Promise<RollbackResult> {
    // Branch merge rollback - merge target branch state
    throw new Error('Branch merge rollback not yet implemented');
  }

  private async executeCherryPickRollback(tree: ChangeTree, plan: RollbackPlan): Promise<RollbackResult> {
    // Cherry-pick specific changes
    throw new Error('Cherry-pick rollback not yet implemented');
  }

  // ========================================================================
  // ANALYSIS AND UTILITIES
  // ========================================================================

  private async analyzeRollbackPath(
    tree: ChangeTree,
    targetNodeId: string,
    currentNodeId: string,
    strategy: RollbackPlan['strategy']
  ): Promise<{
    affectedNodes: string[];
    conflicts: RollbackConflict[];
    previewChanges: Array<{ type: 'add' | 'remove' | 'modify'; nodeId: string; description: string }>;
    warnings: string[];
  }> {
    const affectedNodes = this.getPathBetweenNodes(tree, targetNodeId, currentNodeId);
    const conflicts: RollbackConflict[] = [];
    const warnings: string[] = [];
    const previewChanges: Array<{ type: 'add' | 'remove' | 'modify'; nodeId: string; description: string }> = [];

    // Analyze each affected node
    for (const nodeId of affectedNodes) {
      const node = tree.nodes.get(nodeId)!;
      
      // Check for dependencies
      if (node.metadata.dependencies) {
        for (const depId of node.metadata.dependencies) {
          if (!affectedNodes.includes(depId)) {
            conflicts.push({
              id: crypto.randomUUID(),
              type: 'dependency',
              description: `Change ${nodeId} depends on ${depId} which won't be rolled back`,
              affectedNodes: [nodeId, depId],
              resolutionOptions: [
                { strategy: 'include_dependency', description: 'Include dependency in rollback', safe: true },
                { strategy: 'break_dependency', description: 'Break dependency (may cause issues)', safe: false }
              ]
            });
          }
        }
      }

      // Add to preview
      previewChanges.push({
        type: 'remove',
        nodeId,
        description: node.metadata.description
      });
    }

    return { affectedNodes, conflicts, previewChanges, warnings };
  }

  private calculateComplexity(analysis: any): 'simple' | 'moderate' | 'complex' {
    const conflictCount = analysis.conflicts.length;
    const affectedCount = analysis.affectedNodes.length;

    if (conflictCount === 0 && affectedCount <= 5) return 'simple';
    if (conflictCount <= 2 && affectedCount <= 15) return 'moderate';
    return 'complex';
  }

  private async validateRollbackPlan(tree: ChangeTree, plan: RollbackPlan): Promise<{ valid: boolean; reason?: string }> {
    // Check if target node still exists
    if (!tree.nodes.has(plan.targetNodeId)) {
      return { valid: false, reason: 'Target node no longer exists' };
    }

    // Check if affected nodes haven't changed
    for (const nodeId of plan.affectedNodes) {
      if (!tree.nodes.has(nodeId)) {
        return { valid: false, reason: `Affected node ${nodeId} no longer exists` };
      }
    }

    return { valid: true };
  }

  private reconstructDocumentState(tree: ChangeTree, nodeId: string): any {
    // Reconstruct document state at a specific node
    const path = this.getPathToNode(tree, nodeId);
    let state: any = {};

    for (const pathNodeId of path) {
      const node = tree.nodes.get(pathNodeId);
      if (node) {
        // Apply the change to build up the state
        state = this.applyChangeToState(state, node);
      }
    }

    return state;
  }

  private applyChangeToState(state: any, change: ChangeNode): any {
    // Apply a single change to a state - simplified implementation
    switch (change.changeType) {
      case 'document_create':
      case 'document_update':
        return { ...state, content: change.content };
      case 'basket_update':
        return { ...state, ...change.content };
      default:
        return state;
    }
  }

  private async applySelectiveChanges(tree: ChangeTree, excludeNodeIds: string[]): Promise<any> {
    // Reconstruct state excluding specific changes
    const allNodes = Array.from(tree.nodes.keys());
    const includedNodes = allNodes.filter(id => !excludeNodeIds.includes(id));
    
    // Sort by version to apply in order
    const sortedNodes = includedNodes
      .map(id => tree.nodes.get(id)!)
      .sort((a, b) => a.version - b.version);

    let state: any = {};
    for (const node of sortedNodes) {
      state = this.applyChangeToState(state, node);
    }

    return state;
  }

  // ========================================================================
  // TREE UTILITIES
  // ========================================================================

  private getOrCreateTree(documentId: string): ChangeTree {
    if (!this.changeTrees.has(documentId)) {
      const rootId = `root_${documentId}`;
      this.changeTrees.set(documentId, {
        documentId,
        rootNode: rootId,
        nodes: new Map(),
        branches: new Map([['main', []]]),
        activeNode: rootId,
        lastModified: new Date().toISOString()
      });
    }
    return this.changeTrees.get(documentId)!;
  }

  private getTree(documentId: string): ChangeTree | null {
    return this.changeTrees.get(documentId) || null;
  }

  private getPathToNode(tree: ChangeTree, nodeId: string): string[] {
    const path: string[] = [];
    let current = nodeId;

    while (current && current !== tree.rootNode) {
      path.unshift(current);
      const node = tree.nodes.get(current);
      current = node?.parentNodes[0] || '';
    }

    return path;
  }

  private getPathBetweenNodes(tree: ChangeTree, fromNodeId: string, toNodeId: string): string[] {
    const fromPath = this.getPathToNode(tree, fromNodeId);
    const toPath = this.getPathToNode(tree, toNodeId);

    // Find the nodes between from and to
    const fromIndex = toPath.indexOf(fromNodeId);
    if (fromIndex === -1) {
      // Nodes are on different branches - need more complex logic
      return [];
    }

    return toPath.slice(fromIndex + 1);
  }

  private findCommonAncestor(tree: ChangeTree, branch1: string[], branch2: string[]): string {
    // Find the latest common node between two branches
    for (let i = Math.min(branch1.length, branch2.length) - 1; i >= 0; i--) {
      if (branch1[i] === branch2[i]) {
        return branch1[i];
      }
    }
    return tree.rootNode;
  }

  private calculateChecksum(content: any): string {
    // Simple checksum - in production use proper hashing
    return btoa(JSON.stringify(content)).substring(0, 16);
  }

  private async createMergePlan(tree: ChangeTree, changesToMerge: string[], targetBranch: string[]): Promise<any> {
    // Create a plan for merging changes
    return {
      changesToApply: changesToMerge,
      conflicts: [],
      strategy: 'auto'
    };
  }

  private async executeMergePlan(documentId: string, plan: any): Promise<RollbackResult> {
    // Execute merge plan
    return {
      success: true,
      newActiveNode: '',
      appliedChanges: plan.changesToApply,
      resolvedConflicts: [],
      warnings: [],
      newDocumentState: {},
      rollbackId: crypto.randomUUID()
    };
  }

  private recordRollback(documentId: string, result: RollbackResult): void {
    if (!this.rollbackHistory.has(documentId)) {
      this.rollbackHistory.set(documentId, []);
    }
    
    const history = this.rollbackHistory.get(documentId)!;
    history.push(result);
    
    // Keep only recent rollbacks
    if (history.length > 50) {
      history.splice(0, history.length - 50);
    }
  }

  // ========================================================================
  // PUBLIC QUERY METHODS
  // ========================================================================

  /**
   * Get change history for a document
   */
  getChangeHistory(documentId: string, limit?: number): ChangeNode[] {
    const tree = this.getTree(documentId);
    if (!tree) return [];

    const nodes = Array.from(tree.nodes.values())
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    return limit ? nodes.slice(0, limit) : nodes;
  }

  /**
   * Get ancestry statistics
   */
  getAncestryStats(documentId: string): {
    totalChanges: number;
    totalBranches: number;
    currentVersion: number;
    lastModified: string;
    rollbackCount: number;
  } {
    const tree = this.getTree(documentId);
    const rollbacks = this.rollbackHistory.get(documentId) || [];
    
    if (!tree) {
      return {
        totalChanges: 0,
        totalBranches: 0,
        currentVersion: 0,
        lastModified: '',
        rollbackCount: 0
      };
    }

    const currentNode = tree.nodes.get(tree.activeNode);
    
    return {
      totalChanges: tree.nodes.size,
      totalBranches: tree.branches.size,
      currentVersion: currentNode?.version || 0,
      lastModified: tree.lastModified,
      rollbackCount: rollbacks.length
    };
  }
}

// ============================================================================
// FACTORY FUNCTION
// ============================================================================

let globalAncestryManager: ChangeAncestryManager | null = null;

export function getChangeAncestryManager(): ChangeAncestryManager {
  if (!globalAncestryManager) {
    globalAncestryManager = new ChangeAncestryManager();
  }
  return globalAncestryManager;
}