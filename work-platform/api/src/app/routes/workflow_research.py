"""
Deterministic Research Workflow Endpoint

Part of Workflow-First Architecture (Phase 1):
- Explicit parameters (no TP orchestration)
- Direct specialist invocation
- Full context loading (WorkBundle pattern)
- Auditable execution tracking

Strategic Goal: Prove specialist agents work reliably before adding
TP intelligence layer (Phase 2)
"""

from typing import Optional
from uuid import UUID
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from app.utils.jwt import verify_jwt
from app.utils.supabase_client import supabase_admin_client as supabase
from agents_sdk.research_agent_sdk import ResearchAgentSDK
from agents_sdk.work_bundle import WorkBundle
from yarnnn_agents.session import AgentSession
import logging

router = APIRouter(prefix="/api/work/research", tags=["workflows"])
logger = logging.getLogger(__name__)


class ResearchWorkflowRequest(BaseModel):
    """Deterministic research workflow parameters."""
    basket_id: str
    task_description: str
    research_scope: Optional[str] = "general"  # general, competitor, market, technical
    depth: Optional[str] = "standard"  # quick, standard, deep
    output_format: Optional[str] = "markdown"  # markdown, json, structured
    priority: Optional[int] = 5


class ResearchWorkflowResponse(BaseModel):
    """Research workflow execution result."""
    work_request_id: str
    work_ticket_id: str
    agent_session_id: str
    status: str  # pending, running, completed, failed
    outputs: list[dict]  # work_outputs generated by agent
    execution_time_ms: Optional[int]
    message: str


@router.post("/execute", response_model=ResearchWorkflowResponse)
async def execute_research_workflow(
    request: ResearchWorkflowRequest,
    user: dict = Depends(verify_jwt)
):
    """
    Execute deterministic research workflow.

    Flow:
    1. Validate permissions (workspace, basket, trial limits)
    2. Load context (WorkBundle: blocks + assets + config)
    3. Create work_request + work_ticket (tracking)
    4. Execute ResearchAgentSDK with context
    5. Return structured outputs

    Args:
        request: Research workflow parameters
        user: Authenticated user from JWT

    Returns:
        Research workflow execution result with outputs

    Raises:
        401: Authentication failed
        403: Permission denied or trial limit exceeded
        404: Basket not found
        500: Execution error
    """
    user_id = user.get("sub") or user.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Invalid user token")

    logger.info(
        f"[RESEARCH WORKFLOW] Starting: user={user_id}, basket={request.basket_id}"
    )

    try:
        # Step 1: Validate basket access and get workspace
        basket_response = supabase.table("baskets").select(
            "id, workspace_id, name"
        ).eq("id", request.basket_id).single().execute()

        if not basket_response.data:
            raise HTTPException(status_code=404, detail="Basket not found")

        basket = basket_response.data
        workspace_id = basket["workspace_id"]

        # TODO: Add workspace permission check (verify user has access)
        # TODO: Add trial limit check (work_requests count)

        # Step 2: Get or create research agent session (persistent per basket)
        research_session = await AgentSession.get_or_create(
            basket_id=request.basket_id,
            workspace_id=workspace_id,
            agent_type="research",
            user_id=user_id,
        )

        logger.info(
            f"[RESEARCH WORKFLOW] Agent session: {research_session.id}"
        )

        # Step 3: Create work_request (for trial tracking & billing)
        work_request_data = {
            "workspace_id": workspace_id,
            "basket_id": request.basket_id,
            "user_id": user_id,
            "request_type": "research_workflow",
            "request_data": {
                "task_description": request.task_description,
                "research_scope": request.research_scope,
                "depth": request.depth,
                "output_format": request.output_format,
            },
            "status": "pending",
        }
        work_request_response = supabase.table("work_requests").insert(
            work_request_data
        ).execute()
        work_request_id = work_request_response.data[0]["id"]

        # Step 4: Create work_ticket (execution tracking)
        work_ticket_data = {
            "work_request_id": work_request_id,
            "agent_session_id": research_session.id,
            "workspace_id": workspace_id,
            "basket_id": request.basket_id,
            "agent_type": "research",
            "status": "pending",
            "metadata": {
                "workflow": "deterministic_research",
                "task_description": request.task_description,
                "research_scope": request.research_scope,
                "depth": request.depth,
            },
        }
        work_ticket_response = supabase.table("work_tickets").insert(
            work_ticket_data
        ).execute()
        work_ticket_id = work_ticket_response.data[0]["id"]

        logger.info(
            f"[RESEARCH WORKFLOW] Created: work_request={work_request_id}, "
            f"work_ticket={work_ticket_id}"
        )

        # Step 5: Load context (WorkBundle pattern - same as TP staging)
        # TODO: Implement context loading (blocks, assets, config)
        # For now, create empty bundle (to be implemented in Step 3)
        context_bundle = WorkBundle(
            blocks=[],  # TODO: Load substrate blocks
            reference_assets=[],  # TODO: Load reference assets
            agent_config={},  # TODO: Load agent config
        )

        # Step 6: Update work_ticket status to running
        supabase.table("work_tickets").update({
            "status": "running",
            "started_at": "now()",
        }).eq("id", work_ticket_id).execute()

        # Step 7: Execute ResearchAgentSDK with context
        # TODO: Implement actual execution (to be completed in Step 3)
        # For now, return pending status

        logger.info(
            f"[RESEARCH WORKFLOW] Execution pending (context loading to be implemented)"
        )

        return ResearchWorkflowResponse(
            work_request_id=work_request_id,
            work_ticket_id=work_ticket_id,
            agent_session_id=research_session.id,
            status="pending",
            outputs=[],
            execution_time_ms=None,
            message="Research workflow created (execution to be implemented in Step 3)",
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"[RESEARCH WORKFLOW] Failed: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Research workflow execution failed: {str(e)}"
        )
